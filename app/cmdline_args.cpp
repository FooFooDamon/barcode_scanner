/*
 * APIs for parsing and validating command-line arguments.
 *
 * Copyright (c) 2024 Man Hung-Coeng <udc577@126.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/

#include "cmdline_args.hpp"

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <getopt.h>
#include <assert.h>

#include <string>
#include <vector>
#include <map>
#include <iostream>

#include "versions.hpp"
#include "biz_common.hpp"

// Must be coincident with the copyright info at the beginning of this file.
#ifndef COPYRIGHT_STRING
#define COPYRIGHT_STRING                "Copyright (c) 2024 Man Hung-Coeng <udc577@126.com>\n" \
                                        "Licensed under the Apache License, Version 2.0"
#endif

#ifndef BRIEF_INTRO
#define BRIEF_INTRO                     "Detect barcode from camera or file"
#endif

#ifndef USAGE_FORMAT
#define USAGE_FORMAT                    "[OPTION...] [FILE...]"
#endif

#define __CSTR(x)                       #x
#define CSTR(x)                         __CSTR(x)

#ifndef PRODUCT_VERSION
#define PRODUCT_VERSION                 CSTR(MAJOR_VER) "." CSTR(MINOR_VER) "." CSTR(PATCH_VER)
#endif

#define BIZ_TYPE_CANDIDATES             "normal,test"
#define BIZ_TYPE_DEFAULT                "normal"

#ifdef HAS_CONFIG_FILE
#ifndef DEFAULT_CONF_FILE
#define DEFAULT_CONF_FILE               "config.ini"
#endif
#endif

#ifdef HAS_LOGGER

#ifndef DEFAULT_LOG_FILE
#define DEFAULT_LOG_FILE                "unnamed.log"
#endif

#ifndef LOG_LEVEL_CANDIDATES
#define LOG_LEVEL_CANDIDATES            "debug,info,notice,warning,error,critical"
#endif

#ifndef LOG_LEVEL_DEFAULT
#define LOG_LEVEL_DEFAULT               "warning"
#endif

#endif // #ifdef HAS_LOGGER

#define IMG_SOURCE_CANDIDATES           "camera,pic,video"
#define IMG_SOURCE_DEFAULT              "camera"

#define DEVICE_ID_AUTO                  -1
#define DEFAULT_DEVICE_ID_MAX           32
#define DEFAULT_DEVICE_PREFIX           "/dev/video"

#define CAP_WIDTH_MIN                   128
#define CAP_WIDTH_MAX                   4096
#define CAP_WIDTH_DEFAULT               640

#define CAP_HEIGHT_MIN                  128
#define CAP_HEIGHT_MAX                  4096
#define CAP_HEIGHT_DEFAULT              480

#define CAP_FPS_MIN                     0.1
#define CAP_FPS_MAX                     120.0
#define CAP_FPS_DEFAULT                 15.0

#define CAP_FORMAT_CANDIDATES           "auto,nv12,grey"
#define CAP_FORMAT_DEFAULT              "auto"

#ifndef MAX_DETECT_THREADS
#define MAX_DETECT_THREADS              64
#endif

#define DEFAULT_BACKEND                 AUTO_BACKEND

cmd_args_t parse_cmdline(int argc, char **argv)
{
    const struct
    {
        struct option content;
        const char* const description;
    } OPTION_RULES[] = {
        // name (long option), has_arg (no_*, required_* or optional_*), flag (fixed to NULL), val (short option or 0)
        // description string with proper \t and \n characters
        {
            { "help", no_argument, nullptr, 'h' },
            "\t\tShow this help message."
        },
        {
            { "copyright", no_argument, nullptr, 0 },
            "\tShow copyright info."
        },
        {
            { "version", no_argument, nullptr, 'v' },
            "\t\tShow product version number."
        },
        {
            { "vcs-version", no_argument, nullptr, 0 },
            "\tShow version number generated by version control system."
        },
#ifdef HAS_LOGGER
        {
            { "logfile", required_argument, nullptr, 0 },
            " /PATH/TO/LOG/FILE\n\t\t\tSpecify log file. Default to " DEFAULT_LOG_FILE "."
        },
        {
            { "loglevel", required_argument, nullptr, 0 },
            " {" LOG_LEVEL_CANDIDATES "}\n\t\t\tSpecify log level. Default to " LOG_LEVEL_DEFAULT "."
        },
#else
        {
            { "verbose", no_argument, nullptr, 'V' },
            "\t\tRun in verbose mode to produce more messages."
        },
        {
            { "debug", no_argument, nullptr, 0 },
            "\t\tProduce all messages of verbose mode, plus debug ones."
        },
#endif
#ifdef HAS_CONFIG_FILE
        {
            { "config", required_argument, nullptr, 'c' },
            " /PATH/TO/CONFIG/FILE\n\t\t\tSpecify configuration file. Default to " DEFAULT_CONF_FILE "."
        },
#endif
        {
            { "gui", no_argument, nullptr, 'g' },
            "\t\tUse GUI for extra displaying."
        },
        {
            { "biz", required_argument, nullptr, 'b' },
            " {" BIZ_TYPE_CANDIDATES "}\n\t\t\tSpecify biz type. Default to " BIZ_TYPE_DEFAULT "."
        },
        {
            { "source", required_argument, nullptr, 's' },
            " {" IMG_SOURCE_CANDIDATES "}\n\t\t\tSpecify barcode source. Default to " IMG_SOURCE_DEFAULT "."
        },
        {
            { "device-id", required_argument, nullptr, 'i' },
            " {" CSTR(DEVICE_ID_AUTO) ",0,1,2,...}\n\t\t\tSpecify device ID."
            " Default to " CSTR(DEVICE_ID_AUTO) " (auto selected)."
        },
        {
            { "device-id-max", required_argument, nullptr, 'I' },
            "\tSpecify the upper bound of device ID for auto mode."
            "\n\t\t\tDefault to " CSTR(DEFAULT_DEVICE_ID_MAX) "."
        },
        {
            { "device-prefix", required_argument, nullptr, 0 },
            " PREFIX\n\t\t\tSpecify prefix of device node. Default to " DEFAULT_DEVICE_PREFIX "."
        },
        {
            { "width", required_argument, nullptr, 'W' },
            " WIDTH\n\t\t\tSet frame width to WIDTH ranging from " CSTR(CAP_WIDTH_MIN) " to " CSTR(CAP_WIDTH_MAX)
            ".\n\t\t\tDefault to " CSTR(CAP_WIDTH_DEFAULT) " (px)."
        },
        {
            { "height", required_argument, nullptr, 'H' },
            " HEIGHT\n\t\t\tSet frame height to HEIGHT ranging from " CSTR(CAP_HEIGHT_MIN) " to " CSTR(CAP_HEIGHT_MAX)
            ".\n\t\t\tDefault to " CSTR(CAP_HEIGHT_DEFAULT) " (px)."
        },
        {
            { "fps", required_argument, nullptr, 0 },
            " FPS\n\t\t\tSet frames-per-second to FPS ranging from " CSTR(CAP_FPS_MIN) " to " CSTR(CAP_FPS_MAX)
            ".\n\t\t\tDefault to " CSTR(CAP_FPS_DEFAULT) "."
        },
        {
            { "format", required_argument, nullptr, 0 },
            " {" CAP_FORMAT_CANDIDATES "}\n\t\t\tSpecify frame format. Default to " CAP_FORMAT_DEFAULT "."
        },
        {
            { "detect-threads", required_argument, nullptr, 0 },
            " {0,1,2,...," CSTR(MAX_DETECT_THREADS) "}\n\t\t\tSpecify number of detect threads. Default to 0 (auto)."
        },
        {
            { "backend", required_argument, nullptr, 'B' },
            "\n\t\t\tSpecify software backend. Default to " DEFAULT_BACKEND "."
        },
    };
    std::vector<struct option> long_options;
    std::map<std::string, char> abbr_map;
    std::string short_options;
    cmd_args_t result = {};

    /*
     * NOTE: This block is part of fixed algorithm, DO NOT modify or delete it unless you have a better solution.
     */
    for (size_t i = 0; i < sizeof(OPTION_RULES) / sizeof(OPTION_RULES[0]); ++i)
    {
        const struct option &opt = OPTION_RULES[i].content;

        long_options.push_back(opt);

        abbr_map[opt.name] = opt.val;

        if (opt.val <= 0)
            continue;

        short_options += opt.val;
        if (no_argument == opt.has_arg)
            continue;
        else if (required_argument == opt.has_arg)
            short_options += ':';
        else
            short_options += "::";
    }
    long_options.push_back({});// sentinel

    /*
     * Set some default option values here.
     */
    result.biz = BIZ_TYPE_DEFAULT;
#ifdef HAS_CONFIG_FILE
    result.config_file = DEFAULT_CONF_FILE;
#endif
#ifdef HAS_LOGGER
    result.log_file = DEFAULT_LOG_FILE;
    result.log_level = LOG_LEVEL_DEFAULT;
#endif
    result.source = IMG_SOURCE_DEFAULT;
    result.format = CAP_FORMAT_DEFAULT;
    result.dev_id = DEVICE_ID_AUTO;
    result.dev_id_max = DEFAULT_DEVICE_ID_MAX;
    result.dev_prefix = DEFAULT_DEVICE_PREFIX;
    result.fps = CAP_FPS_DEFAULT;
    result.width = CAP_WIDTH_DEFAULT;
    result.height = CAP_HEIGHT_DEFAULT;
    result.detect_threads = 0;
    result.backend = DEFAULT_BACKEND;

    while (true)
    {
        int option_index = 0;
        int c = getopt_long(argc, argv, short_options.c_str(), &long_options[0], &option_index);

        if (-1 == c) // all parsed
            break;
        else if (0 == c)
            c = abbr_map[long_options[option_index].name]; // re-mapped to short option and continue
        else
        {
            // empty block for the integrity of if-else statement
        } // continue as follows

        if (0 == c) // for long-only options
        {
            const char *long_opt = long_options[option_index].name;

            if (0 == strcmp(long_opt, "copyright"))
            {
                printf("%s\n", COPYRIGHT_STRING);
                exit(EXIT_SUCCESS);
            }
            else if (0 == strcmp(long_opt, "vcs-version"))
            {
                printf("%s\n", __VER__);
                exit(EXIT_SUCCESS);
            }
#ifdef HAS_LOGGER
            else if (0 == strcmp(long_opt, "logfile"))
                result.log_file = optarg;
            else if (0 == strcmp(long_opt, "loglevel"))
                result.log_level = optarg;
#else
            else if (abbr_map["debug"] == c)
                result.debug = true;
#endif
            else if (0 == strcmp(long_opt, "fps"))
                result.fps = atof(optarg);
            else if (0 == strcmp(long_opt, "format"))
                result.format = optarg;
            else if (0 == strcmp(long_opt, "detect-threads"))
                result.detect_threads = atoi(optarg);
            else if (0 == strcmp(long_opt, "device-prefix"))
                result.dev_prefix = optarg;
            else
            {
                fprintf(stderr, "*** Are you forgetting to handle --%s option??\n", long_opt);
                exit(EINVAL);
            }
        } // c == 0: for long-only options
        else if (abbr_map["biz"] == c)
            result.biz = optarg;
#ifdef HAS_CONFIG_FILE
        else if (abbr_map["config"] == c)
            result.config_file = optarg;
#endif
        else if (abbr_map["gui"] == c)
            result.use_gui = true;
        else if (abbr_map["source"] == c)
            result.source = optarg;
        else if (abbr_map["device-id"] == c)
            result.dev_id = atoi(optarg);
        else if (abbr_map["device-id-max"] == c)
            result.dev_id_max = atoi(optarg);
        else if (abbr_map["width"] == c)
            result.width = atoi(optarg);
        else if (abbr_map["height"] == c)
            result.height = atoi(optarg);
        else if (abbr_map["backend"] == c)
            result.backend = optarg;
        else if (abbr_map["help"] == c) // NOTE: Branches below rarely need customizing.
        {
            const char *slash = strrchr(argv[0], '/');
            const char *program_name = (nullptr == slash) ? argv[0] : (slash + 1);
            const std::string &backend_desc = std::string(" {") + get_camera_backends() + "}";

            printf("\n%s - %s\n\nUsage: %s %s\n\n", program_name, BRIEF_INTRO, program_name, USAGE_FORMAT);
            for (const auto &rule : OPTION_RULES)
            {
                const struct option &opt = rule.content;
                bool has_short = (opt.val > 0);

                printf("  %c%c%c --%s%s%s\n\n", (has_short ? '-' : ' '), (has_short ? (char)opt.val : ' '),
                    (has_short ? ',' : ' '), opt.name, (('B' == opt.val) ? backend_desc.c_str() : ""),
                    rule.description);
            }
            exit(EXIT_SUCCESS);
        }
        else if (abbr_map["version"] == c)
        {
            printf("%s\n", PRODUCT_VERSION);
            exit(EXIT_SUCCESS);
        }
#ifndef HAS_LOGGER
        else if (abbr_map["verbose"] == c)
            result.verbose = true;
#endif
        else if ('?' == c || ':' == c)
            exit(EINVAL); // getopt_long() will print the reason.
        else // This case should never happen.
        {
            fprintf(stderr, "?? getopt returned character code 0x%x ??\n", c);
            exit(EINVAL);
        }
    } // while (true)

    while (optind < argc)
    {
        result.orphan_args.push_back(argv[optind++]);
    }
    result.img_files = &result.orphan_args;

    return result;
} // cmd_args_t parse_cmdline(int argc, char **argv)

#undef CSTR

template<typename T>
static void assert_comparable_arg(const char *name, const T &val, const T &min, const T &max)
{
    assert(max > min);
    if (val < min || val > max)
    {
        std::cerr << "*** The specified " << name << " exceeds range[" << min << ", " << max << "]!" << std::endl;
        exit(EINVAL);
    }
}

void assert_parsed_args(const cmd_args_t &args)
{
    const struct
    {
        const char *name;
        const char *val;
    } required_str_args[] = {
        { "biz type", args.biz.c_str() },
#ifdef HAS_CONFIG_FILE
        { "config file", args.config_file.c_str() },
#endif
#ifdef HAS_LOGGER
        { "log file", args.log_file.c_str() },
        { "log level", args.log_level.c_str() },
        { "device prefix", args.dev_prefix.c_str() },
        { "backend", args.backend.c_str() },
#endif
    };
    const struct
    {
        const char *name;
        const char *val;
        const char *candidates;
    } enum_str_args[] = {
        { "biz type", args.biz.c_str(), BIZ_TYPE_CANDIDATES },
#ifdef HAS_LOGGER
        { "log level", args.log_level.c_str(), LOG_LEVEL_CANDIDATES },
#endif
        { "image source", args.source.c_str(), IMG_SOURCE_CANDIDATES },
        { "frame format", args.format.c_str(), CAP_FORMAT_CANDIDATES },
        { "backend", args.backend.c_str(), get_camera_backends() },
    };

    for (const auto &arg : required_str_args)
    {
        if (nullptr == arg.val || '\0' == arg.val[0])
        {
            fprintf(stderr, "*** %s is null or not specified!\n", arg.name);
            exit(EINVAL);
        }
    }

    for (const auto &arg : enum_str_args)
    {
        const char *ptr = (arg.val && arg.val[0]) ? strstr(arg.candidates, arg.val) : nullptr;
        size_t len = ptr ? strlen(arg.val) : 0;

        if (nullptr == ptr || (',' != ptr[len] && '\0' != ptr[len]))
        {
            fprintf(stderr, "*** Invalid %s: %s\nMust be one of {%s}\n", arg.name, arg.val, arg.candidates);
            exit(EINVAL);
        }
    }

    assert_comparable_arg("device id max", args.dev_id_max, 0, 99999);
    assert_comparable_arg("device id", args.dev_id, -1, args.dev_id_max);
    assert_comparable_arg("frame width", args.width, CAP_WIDTH_MIN, CAP_WIDTH_MAX);
    assert_comparable_arg("frame height", args.height, CAP_HEIGHT_MIN, CAP_HEIGHT_MAX);
    assert_comparable_arg("frame FPS", args.fps, (float)CAP_FPS_MIN, (float)CAP_FPS_MAX);
    assert_comparable_arg("detect thread count", args.detect_threads, 0, MAX_DETECT_THREADS);

    if ("camera" != args.source && args.img_files->empty())
    {
        fprintf(stderr, "*** Image or video file(s) not specified!\n");
        exit(EINVAL);
    }
} // void assert_parsed_args(const cmd_args_t &args)

/*
 * ================
 *   CHANGE LOG
 * ================
 *
 * >>> 2024-05-10, Man Hung-Coeng <udc577@126.com>:
 *  01. Create.
 *
 * >>> 2024-05-18, Man Hung-Coeng <udc577@126.com>:
 *  01. Fix the bug of parsing --debug option.
 *  02. Rename option --camera-id* to --device-id*.
 *  03. Add option --device-prefix, --detect-threads and --backend.
 */

